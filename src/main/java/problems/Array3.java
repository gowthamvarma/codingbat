package problems;

public class Array3 {
	// url :: https://codingbat.com/java/Array-3

	// url :: https://codingbat.com/prob/p189576
	/*
	 * Statement :: Consider the leftmost and righmost appearances of some value in
	 * an array. We'll say that the "span" is the number of elements between the two
	 * inclusive. A single value has a span of 1. Returns the largest span found in
	 * the given array. (Efficiency is not a priority.)
	 */
	public int maxSpan(int[] nums) {
		return 0;
	}

	// url :: https://codingbat.com/prob/p159339
	/*
	 * Statement :: Return an array that contains exactly the same numbers as the
	 * given array, but rearranged so that every 3 is immediately followed by a 4.
	 * Do not move the 3's, but every other number may move. The array contains the
	 * same number of 3's and 4's, every 3 has a number after it that is not a 3 or
	 * 4, and a 3 appears in the array before any 4.
	 */
	public int[] fix34(int[] nums) {
		return null;
	}

	// url :: https://codingbat.com/prob/p125819
	/*
	 * Statement :: (This is a slightly harder version of the fix34 problem.) Return
	 * an array that contains exactly the same numbers as the given array, but
	 * rearranged so that every 4 is immediately followed by a 5. Do not move the
	 * 4's, but every other number may move. The array contains the same number of
	 * 4's and 5's, and every 4 has a number after it that is not a 4. In this
	 * version, 5's may appear anywhere in the original array.
	 */
	public int[] fix45(int[] nums) {
		return null;
	}

	// url :: https://codingbat.com/prob/p158767
	/*
	 * Statement :: Given a non-empty array, return true if there is a place to
	 * split the array so that the sum of the numbers on one side is equal to the
	 * sum of the numbers on the other side.
	 */
	public boolean canBalance(int[] nums) {
		return false;
	}

	// url :: https://codingbat.com/prob/p134022
	/*
	 * Statement :: Given two arrays of ints sorted in increasing order, outer and
	 * inner, return true if all of the numbers in inner appear in outer. The best
	 * solution makes only a single "linear" pass of both arrays, taking advantage
	 * of the fact that both arrays are already in sorted order.
	 */
	public boolean linearIn(int[] outer, int[] inner) {
		return false;
	}

	// url :: https://codingbat.com/prob/p155405
	/*
	 * Statement :: Given n>=0, create an array length n*n with the following
	 * pattern, shown here for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1} (spaces added
	 * to show the 3 groups).
	 */
	public int[] squareUp(int n) {
		return null;
	}

	// url :: https://codingbat.com/prob/p104090
	/*
	 * Statement :: Given n>=0, create an array with the pattern {1,    1, 2,    1,
	 * 2, 3,   ... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the
	 * length of the array will be 1 + 2 + 3 ... + n, which is known to sum to
	 * exactly n*(n + 1)/2.
	 */
	public int[] seriesUp(int n) {
		return null;
	}

	// url :: https://codingbat.com/prob/p196409
	/*
	 * Statement :: We'll say that a "mirror" section in an array is a group of
	 * contiguous elements such that somewhere in the array, the same group appears
	 * in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9,
	 * 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest
	 * mirror section found in the given array.
	 */
	public int maxMirror(int[] nums) {
		return 0;
	}

	// url :: https://codingbat.com/prob/p193817
	/*
	 * Statement :: Say that a "clump" in an array is a series of 2 or more adjacent
	 * elements of the same value. Return the number of clumps in the given array.
	 */
	public int countClumps(int[] nums) {
		return 0;
	}

}

